{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3","program":"/home/sna/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rls","arguments":["--crate-name","float_cmp","--edition=2018","/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","--json=diagnostic-rendered-ansi","--crate-type","lib","--emit=dep-info,metadata","-C","embed-bitcode=no","-C","debuginfo=2","-C","metadata=5b6e11b29a994a32","-C","extra-filename=-5b6e11b29a994a32","--out-dir","/home/sna/project/koompi-desktop/desktop/target/rls/debug/deps","-L","dependency=/home/sna/project/koompi-desktop/desktop/target/rls/debug/deps","--cap-lints","allow","--error-format=json","--sysroot","/home/sna/.rustup/toolchains/stable-x86_64-unknown-linux-gnu"],"output":"/home/sna/project/koompi-desktop/desktop/target/rls/debug/deps/libfloat_cmp-5b6e11b29a994a32.rmeta"},"prelude":{"crate_id":{"name":"float_cmp","disambiguator":[11827270614947931020,1607273231573636192]},"crate_root":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src","external_crates":[{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[12933703438800314702,5774803219644544316]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[18134888982608726624,15478788479473023395]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[6673302632599048863,4691371433878452070]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[11457885127507258025,479752930606968628]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[6007655421670680970,17748288058820543149]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[4051320655186846034,14773827427477085591]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[3672675044024306215,7179779047398453100]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[14739525726177289408,3061276640434149652]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":9,"id":{"name":"hashbrown","disambiguator":[2246841610299105657,12905561680815043912]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":10,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[4036557704906104068,994131407893854156]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":11,"id":{"name":"rustc_demangle","disambiguator":[7443407023664770875,11250036483448109314]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":12,"id":{"name":"addr2line","disambiguator":[10148669557414888454,6400214184476534778]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":13,"id":{"name":"gimli","disambiguator":[4006540472161665961,15205760237192158299]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":14,"id":{"name":"object","disambiguator":[16043199729901662453,7825522302763349882]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":15,"id":{"name":"miniz_oxide","disambiguator":[5738570549504868290,14845130516100231771]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":16,"id":{"name":"adler","disambiguator":[6807687926185025542,9498922200428406688]}},{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","num":17,"id":{"name":"panic_unwind","disambiguator":[6171827839412267364,4338689175470013405]}}],"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":113,"byte_end":7599,"line_start":4,"line_end":200,"column_start":1,"column_end":36}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":9},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":7301,"byte_end":7305,"line_start":185,"line_end":185,"column_start":21,"column_end":25},"alias_span":null,"name":"Ulps","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":27},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":7344,"byte_end":7356,"line_start":188,"line_end":188,"column_start":24,"column_end":36},"alias_span":null,"name":"ApproxEqUlps","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":45},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":7418,"byte_end":7431,"line_start":192,"line_end":192,"column_start":25,"column_end":38},"alias_span":null,"name":"ApproxOrdUlps","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":61},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":7461,"byte_end":7469,"line_start":195,"line_end":195,"column_start":20,"column_end":28},"alias_span":null,"name":"ApproxEq","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":95},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":7471,"byte_end":7480,"line_start":195,"line_end":195,"column_start":30,"column_end":39},"alias_span":null,"name":"F32Margin","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":103},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":7482,"byte_end":7491,"line_start":195,"line_end":195,"column_start":41,"column_end":50},"alias_span":null,"name":"F64Margin","value":"","parent":{"krate":0,"index":0}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":113,"byte_end":7599,"line_start":4,"line_end":200,"column_start":1,"column_end":36},"name":"","qualname":"::","value":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":7},{"krate":0,"index":8},{"krate":0,"index":24},{"krate":0,"index":25},{"krate":0,"index":37},{"krate":0,"index":38},{"krate":0,"index":55},{"krate":0,"index":56},{"krate":0,"index":91},{"krate":0,"index":92},{"krate":0,"index":93},{"krate":0,"index":94}],"decl_id":null,"docs":" # float-cmp","sig":null,"attributes":[{"value":"/ # float-cmp","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":113,"byte_end":128,"line_start":4,"line_end":4,"column_start":1,"column_end":16}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":129,"byte_end":132,"line_start":5,"line_end":5,"column_start":1,"column_end":4}},{"value":"/ float-cmp defines and implements traits for approximate comparison of floating point types","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":133,"byte_end":227,"line_start":6,"line_end":6,"column_start":1,"column_end":95}},{"value":"/ which have fallen away from exact equality due to the limited precision available within","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":228,"byte_end":320,"line_start":7,"line_end":7,"column_start":1,"column_end":93}},{"value":"/ floating point representations. Implementations of these traits are provided for `f32`","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":321,"byte_end":411,"line_start":8,"line_end":8,"column_start":1,"column_end":91}},{"value":"/ and `f64` types.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":412,"byte_end":432,"line_start":9,"line_end":9,"column_start":1,"column_end":21}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":433,"byte_end":436,"line_start":10,"line_end":10,"column_start":1,"column_end":4}},{"value":"/ When I was a kid in the '80s, the programming rule was \"Never compare floating point","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":437,"byte_end":525,"line_start":11,"line_end":11,"column_start":1,"column_end":89}},{"value":"/ numbers\". If you can follow that rule and still get the outcome you desire, then more","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":526,"byte_end":615,"line_start":12,"line_end":12,"column_start":1,"column_end":90}},{"value":"/ power to you. However, if you really do need to compare them, this crate provides a","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":616,"byte_end":703,"line_start":13,"line_end":13,"column_start":1,"column_end":88}},{"value":"/ reasonable way to do so.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":704,"byte_end":732,"line_start":14,"line_end":14,"column_start":1,"column_end":29}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":733,"byte_end":736,"line_start":15,"line_end":15,"column_start":1,"column_end":4}},{"value":"/ Another crate `efloat` offers another solution by providing a floating point type that","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":737,"byte_end":827,"line_start":16,"line_end":16,"column_start":1,"column_end":91}},{"value":"/ tracks its error bounds as operations are performed on it, and thus can implement the","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":828,"byte_end":917,"line_start":17,"line_end":17,"column_start":1,"column_end":90}},{"value":"/ `ApproxEq` trait in this crate more accurately, without specifying a `Margin`.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":918,"byte_end":1000,"line_start":18,"line_end":18,"column_start":1,"column_end":83}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1001,"byte_end":1004,"line_start":19,"line_end":19,"column_start":1,"column_end":4}},{"value":"/ The recommended go-to solution (although it may not be appropriate in all cases) is the","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1005,"byte_end":1096,"line_start":20,"line_end":20,"column_start":1,"column_end":92}},{"value":"/ `approx_eq()` function in the `ApproxEq` trait (or better yet, the macros).  For `f32`","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1097,"byte_end":1187,"line_start":21,"line_end":21,"column_start":1,"column_end":91}},{"value":"/ and `f64`, the `F32Margin` and `F64Margin` types are provided for specifying margins as","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1188,"byte_end":1279,"line_start":22,"line_end":22,"column_start":1,"column_end":92}},{"value":"/ both an epsilon value and an ULPs value, and defaults are provided via `Default`","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1280,"byte_end":1364,"line_start":23,"line_end":23,"column_start":1,"column_end":85}},{"value":"/ (although there is no perfect default value that is always appropriate, so beware).","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1365,"byte_end":1452,"line_start":24,"line_end":24,"column_start":1,"column_end":88}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1453,"byte_end":1456,"line_start":25,"line_end":25,"column_start":1,"column_end":4}},{"value":"/ Several other traits are provided including `Ulps`, `ApproxEqUlps`, `ApproxOrdUlps`, and","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1457,"byte_end":1549,"line_start":26,"line_end":26,"column_start":1,"column_end":93}},{"value":"/ `ApproxEqRatio`.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1550,"byte_end":1570,"line_start":27,"line_end":27,"column_start":1,"column_end":21}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1571,"byte_end":1574,"line_start":28,"line_end":28,"column_start":1,"column_end":4}},{"value":"/ ## The problem","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1575,"byte_end":1593,"line_start":29,"line_end":29,"column_start":1,"column_end":19}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1594,"byte_end":1597,"line_start":30,"line_end":30,"column_start":1,"column_end":4}},{"value":"/ Floating point operations must round answers to the nearest representable number. Multiple","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1598,"byte_end":1692,"line_start":31,"line_end":31,"column_start":1,"column_end":95}},{"value":"/ operations may result in an answer different from what you expect. In the following example,","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1693,"byte_end":1789,"line_start":32,"line_end":32,"column_start":1,"column_end":97}},{"value":"/ the assert will fail, even though the printed output says \"0.45 == 0.45\":","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1790,"byte_end":1867,"line_start":33,"line_end":33,"column_start":1,"column_end":78}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1868,"byte_end":1871,"line_start":34,"line_end":34,"column_start":1,"column_end":4}},{"value":"/ ```should_panic","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1872,"byte_end":1891,"line_start":35,"line_end":35,"column_start":1,"column_end":20}},{"value":"/   # extern crate float_cmp;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1892,"byte_end":1923,"line_start":36,"line_end":36,"column_start":1,"column_end":32}},{"value":"/   # use float_cmp::ApproxEq;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1924,"byte_end":1956,"line_start":37,"line_end":37,"column_start":1,"column_end":33}},{"value":"/   # fn main() {","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1957,"byte_end":1976,"line_start":38,"line_end":38,"column_start":1,"column_end":20}},{"value":"/   let a: f32 = 0.15 + 0.15 + 0.15;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":1977,"byte_end":2015,"line_start":39,"line_end":39,"column_start":1,"column_end":39}},{"value":"/   let b: f32 = 0.1 + 0.1 + 0.25;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2016,"byte_end":2052,"line_start":40,"line_end":40,"column_start":1,"column_end":37}},{"value":"/   println!(\"{} == {}\", a, b);","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2053,"byte_end":2086,"line_start":41,"line_end":41,"column_start":1,"column_end":34}},{"value":"/   assert!(a==b)  // Fails, because they are not exactly equal","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2087,"byte_end":2152,"line_start":42,"line_end":42,"column_start":1,"column_end":66}},{"value":"/   # }","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2153,"byte_end":2162,"line_start":43,"line_end":43,"column_start":1,"column_end":10}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2163,"byte_end":2170,"line_start":44,"line_end":44,"column_start":1,"column_end":8}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2171,"byte_end":2174,"line_start":45,"line_end":45,"column_start":1,"column_end":4}},{"value":"/ This fails because the correct answer to most operations isn't exactly representable, and so","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2175,"byte_end":2271,"line_start":46,"line_end":46,"column_start":1,"column_end":97}},{"value":"/ your computer's processor chooses to represent the answer with the closest value it has","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2272,"byte_end":2363,"line_start":47,"line_end":47,"column_start":1,"column_end":92}},{"value":"/ available. This introduces error, and this error can accumulate as multiple operations are","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2364,"byte_end":2458,"line_start":48,"line_end":48,"column_start":1,"column_end":95}},{"value":"/ performed.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2459,"byte_end":2473,"line_start":49,"line_end":49,"column_start":1,"column_end":15}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2474,"byte_end":2477,"line_start":50,"line_end":50,"column_start":1,"column_end":4}},{"value":"/ ## The solution","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2478,"byte_end":2497,"line_start":51,"line_end":51,"column_start":1,"column_end":20}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2498,"byte_end":2501,"line_start":52,"line_end":52,"column_start":1,"column_end":4}},{"value":"/ With `ApproxEq`, we can get the answer we intend:","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2502,"byte_end":2555,"line_start":53,"line_end":53,"column_start":1,"column_end":54}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2556,"byte_end":2559,"line_start":54,"line_end":54,"column_start":1,"column_end":4}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2560,"byte_end":2567,"line_start":55,"line_end":55,"column_start":1,"column_end":8}},{"value":"/   # #[macro_use]","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2568,"byte_end":2588,"line_start":56,"line_end":56,"column_start":1,"column_end":21}},{"value":"/   # extern crate float_cmp;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2589,"byte_end":2620,"line_start":57,"line_end":57,"column_start":1,"column_end":32}},{"value":"/   # use float_cmp::{ApproxEq, F32Margin};","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2621,"byte_end":2666,"line_start":58,"line_end":58,"column_start":1,"column_end":46}},{"value":"/   # fn main() {","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2667,"byte_end":2686,"line_start":59,"line_end":59,"column_start":1,"column_end":20}},{"value":"/   let a: f32 = 0.15 + 0.15 + 0.15;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2687,"byte_end":2725,"line_start":60,"line_end":60,"column_start":1,"column_end":39}},{"value":"/   let b: f32 = 0.1 + 0.1 + 0.25;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2726,"byte_end":2762,"line_start":61,"line_end":61,"column_start":1,"column_end":37}},{"value":"/   println!(\"{} == {}\", a, b);","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2763,"byte_end":2796,"line_start":62,"line_end":62,"column_start":1,"column_end":34}},{"value":"/   // They are equal, within 2 ulps","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2797,"byte_end":2835,"line_start":63,"line_end":63,"column_start":1,"column_end":39}},{"value":"/   assert!( approx_eq!(f32, a, b, ulps = 2) );","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2836,"byte_end":2885,"line_start":64,"line_end":64,"column_start":1,"column_end":50}},{"value":"/   # }","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2886,"byte_end":2895,"line_start":65,"line_end":65,"column_start":1,"column_end":10}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2896,"byte_end":2903,"line_start":66,"line_end":66,"column_start":1,"column_end":8}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2904,"byte_end":2907,"line_start":67,"line_end":67,"column_start":1,"column_end":4}},{"value":"/ ## Some explanation","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2908,"byte_end":2931,"line_start":68,"line_end":68,"column_start":1,"column_end":24}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2932,"byte_end":2935,"line_start":69,"line_end":69,"column_start":1,"column_end":4}},{"value":"/ We use the term ULP (units of least precision, or units in the last place) to mean the","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":2936,"byte_end":3026,"line_start":70,"line_end":70,"column_start":1,"column_end":91}},{"value":"/ difference between two adjacent floating point representations (adjacent meaning that there is","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3027,"byte_end":3125,"line_start":71,"line_end":71,"column_start":1,"column_end":99}},{"value":"/ no floating point number between them). This term is borrowed from prior work (personally I","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3126,"byte_end":3221,"line_start":72,"line_end":72,"column_start":1,"column_end":96}},{"value":"/ would have chosen \"quanta\"). The size of an ULP (measured as a float) varies","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3222,"byte_end":3302,"line_start":73,"line_end":73,"column_start":1,"column_end":81}},{"value":"/ depending on the exponents of the floating point numbers in question. That is a good thing,","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3303,"byte_end":3398,"line_start":74,"line_end":74,"column_start":1,"column_end":96}},{"value":"/ because as numbers fall away from equality due to the imprecise nature of their representation,","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3399,"byte_end":3498,"line_start":75,"line_end":75,"column_start":1,"column_end":100}},{"value":"/ they fall away in ULPs terms, not in absolute terms.  Pure epsilon-based comparisons are","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3499,"byte_end":3591,"line_start":76,"line_end":76,"column_start":1,"column_end":93}},{"value":"/ absolute and thus don't map well to the nature of the additive error issue. They work fine","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3592,"byte_end":3686,"line_start":77,"line_end":77,"column_start":1,"column_end":95}},{"value":"/ for many ranges of numbers, but not for others (consider comparing -0.0000000028","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3687,"byte_end":3771,"line_start":78,"line_end":78,"column_start":1,"column_end":85}},{"value":"/ to +0.00000097).","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3772,"byte_end":3792,"line_start":79,"line_end":79,"column_start":1,"column_end":21}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3793,"byte_end":3796,"line_start":80,"line_end":80,"column_start":1,"column_end":4}},{"value":"/ ## Using this crate","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3797,"byte_end":3820,"line_start":81,"line_end":81,"column_start":1,"column_end":24}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3821,"byte_end":3824,"line_start":82,"line_end":82,"column_start":1,"column_end":4}},{"value":"/ You can use the `ApproxEq` trait directly like so:","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3825,"byte_end":3879,"line_start":83,"line_end":83,"column_start":1,"column_end":55}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3880,"byte_end":3883,"line_start":84,"line_end":84,"column_start":1,"column_end":4}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3884,"byte_end":3891,"line_start":85,"line_end":85,"column_start":1,"column_end":8}},{"value":"/   # extern crate float_cmp;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3892,"byte_end":3923,"line_start":86,"line_end":86,"column_start":1,"column_end":32}},{"value":"/   # use float_cmp::{ApproxEq, F32Margin};","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3924,"byte_end":3969,"line_start":87,"line_end":87,"column_start":1,"column_end":46}},{"value":"/   # fn main() {","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3970,"byte_end":3989,"line_start":88,"line_end":88,"column_start":1,"column_end":20}},{"value":"/   # let a: f32 = 0.15 + 0.15 + 0.15;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":3990,"byte_end":4030,"line_start":89,"line_end":89,"column_start":1,"column_end":41}},{"value":"/   # let b: f32 = 0.1 + 0.1 + 0.25;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4031,"byte_end":4069,"line_start":90,"line_end":90,"column_start":1,"column_end":39}},{"value":"/     assert!( a.approx_eq(b, F32Margin { ulps: 2, epsilon: 0.0 }) );","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4070,"byte_end":4141,"line_start":91,"line_end":91,"column_start":1,"column_end":72}},{"value":"/   # }","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4142,"byte_end":4151,"line_start":92,"line_end":92,"column_start":1,"column_end":10}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4152,"byte_end":4159,"line_start":93,"line_end":93,"column_start":1,"column_end":8}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4160,"byte_end":4163,"line_start":94,"line_end":94,"column_start":1,"column_end":4}},{"value":"/ We have implemented `From<(f32,i32)>` for `F32Margin` (and similarly for `F64Margin`)","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4164,"byte_end":4253,"line_start":95,"line_end":95,"column_start":1,"column_end":90}},{"value":"/ so you can use this shorthand:","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4254,"byte_end":4288,"line_start":96,"line_end":96,"column_start":1,"column_end":35}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4289,"byte_end":4292,"line_start":97,"line_end":97,"column_start":1,"column_end":4}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4293,"byte_end":4300,"line_start":98,"line_end":98,"column_start":1,"column_end":8}},{"value":"/   # extern crate float_cmp;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4301,"byte_end":4332,"line_start":99,"line_end":99,"column_start":1,"column_end":32}},{"value":"/   # use float_cmp::{ApproxEq, F32Margin};","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4333,"byte_end":4378,"line_start":100,"line_end":100,"column_start":1,"column_end":46}},{"value":"/   # fn main() {","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4379,"byte_end":4398,"line_start":101,"line_end":101,"column_start":1,"column_end":20}},{"value":"/   # let a: f32 = 0.15 + 0.15 + 0.15;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4399,"byte_end":4439,"line_start":102,"line_end":102,"column_start":1,"column_end":41}},{"value":"/   # let b: f32 = 0.1 + 0.1 + 0.25;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4440,"byte_end":4478,"line_start":103,"line_end":103,"column_start":1,"column_end":39}},{"value":"/     assert!( a.approx_eq(b, (0.0, 2)) );","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4479,"byte_end":4523,"line_start":104,"line_end":104,"column_start":1,"column_end":45}},{"value":"/   # }","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4524,"byte_end":4533,"line_start":105,"line_end":105,"column_start":1,"column_end":10}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4534,"byte_end":4541,"line_start":106,"line_end":106,"column_start":1,"column_end":8}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4542,"byte_end":4545,"line_start":107,"line_end":107,"column_start":1,"column_end":4}},{"value":"/ With macros, it is easier to be explicit about which type of margin you wish to set,","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4546,"byte_end":4634,"line_start":108,"line_end":108,"column_start":1,"column_end":89}},{"value":"/ without mentioning the other one (the other one will be zero). But the downside is","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4635,"byte_end":4721,"line_start":109,"line_end":109,"column_start":1,"column_end":87}},{"value":"/ that you have to specify the type you are dealing with:","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4722,"byte_end":4781,"line_start":110,"line_end":110,"column_start":1,"column_end":60}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4782,"byte_end":4785,"line_start":111,"line_end":111,"column_start":1,"column_end":4}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4786,"byte_end":4793,"line_start":112,"line_end":112,"column_start":1,"column_end":8}},{"value":"/   # #[macro_use]","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4794,"byte_end":4814,"line_start":113,"line_end":113,"column_start":1,"column_end":21}},{"value":"/   # extern crate float_cmp;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4815,"byte_end":4846,"line_start":114,"line_end":114,"column_start":1,"column_end":32}},{"value":"/   # use float_cmp::{ApproxEq, F32Margin};","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4847,"byte_end":4892,"line_start":115,"line_end":115,"column_start":1,"column_end":46}},{"value":"/   # fn main() {","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4893,"byte_end":4912,"line_start":116,"line_end":116,"column_start":1,"column_end":20}},{"value":"/   # let a: f32 = 0.15 + 0.15 + 0.15;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4913,"byte_end":4953,"line_start":117,"line_end":117,"column_start":1,"column_end":41}},{"value":"/   # let b: f32 = 0.1 + 0.1 + 0.25;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4954,"byte_end":4992,"line_start":118,"line_end":118,"column_start":1,"column_end":39}},{"value":"/     assert!( approx_eq!(f32, a, b, ulps = 2) );","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":4993,"byte_end":5044,"line_start":119,"line_end":119,"column_start":1,"column_end":52}},{"value":"/     assert!( approx_eq!(f32, a, b, epsilon = 0.00000003) );","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5045,"byte_end":5108,"line_start":120,"line_end":120,"column_start":1,"column_end":64}},{"value":"/     assert!( approx_eq!(f32, a, b, epsilon = 0.00000003, ulps = 2) );","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5109,"byte_end":5182,"line_start":121,"line_end":121,"column_start":1,"column_end":74}},{"value":"/     assert!( approx_eq!(f32, a, b, (0.0, 2)) );","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5183,"byte_end":5234,"line_start":122,"line_end":122,"column_start":1,"column_end":52}},{"value":"/     assert!( approx_eq!(f32, a, b, F32Margin { epsilon: 0.0, ulps: 2 }) );","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5235,"byte_end":5313,"line_start":123,"line_end":123,"column_start":1,"column_end":79}},{"value":"/     assert!( approx_eq!(f32, a, b, F32Margin::default()) );","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5314,"byte_end":5377,"line_start":124,"line_end":124,"column_start":1,"column_end":64}},{"value":"/     assert!( approx_eq!(f32, a, b) ); // uses the default","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5378,"byte_end":5439,"line_start":125,"line_end":125,"column_start":1,"column_end":62}},{"value":"/   # }","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5440,"byte_end":5449,"line_start":126,"line_end":126,"column_start":1,"column_end":10}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5450,"byte_end":5457,"line_start":127,"line_end":127,"column_start":1,"column_end":8}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5458,"byte_end":5461,"line_start":128,"line_end":128,"column_start":1,"column_end":4}},{"value":"/ For most cases, I recommend you use a smallish integer for the `ulps` parameter (1 to 5","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5462,"byte_end":5553,"line_start":129,"line_end":129,"column_start":1,"column_end":92}},{"value":"/ or so), and a similar small multiple of the floating point's EPSILON constant (1.0 to 5.0","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5554,"byte_end":5647,"line_start":130,"line_end":130,"column_start":1,"column_end":94}},{"value":"/ or so), but there are *plenty* of cases where this is insufficient.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5648,"byte_end":5719,"line_start":131,"line_end":131,"column_start":1,"column_end":72}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5720,"byte_end":5723,"line_start":132,"line_end":132,"column_start":1,"column_end":4}},{"value":"/ ## Implementing these traits","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5724,"byte_end":5756,"line_start":133,"line_end":133,"column_start":1,"column_end":33}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5757,"byte_end":5760,"line_start":134,"line_end":134,"column_start":1,"column_end":4}},{"value":"/ You can implement `ApproxEq` for your own complex types like shown below.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5761,"byte_end":5838,"line_start":135,"line_end":135,"column_start":1,"column_end":78}},{"value":"/ The floating point type `F` must be `Copy`, but for large types you can implement","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5839,"byte_end":5924,"line_start":136,"line_end":136,"column_start":1,"column_end":86}},{"value":"/ it for references to your type as shown.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5925,"byte_end":5969,"line_start":137,"line_end":137,"column_start":1,"column_end":45}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5970,"byte_end":5973,"line_start":138,"line_end":138,"column_start":1,"column_end":4}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5974,"byte_end":5981,"line_start":139,"line_end":139,"column_start":1,"column_end":8}},{"value":"/ use float_cmp::ApproxEq;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":5982,"byte_end":6010,"line_start":140,"line_end":140,"column_start":1,"column_end":29}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6011,"byte_end":6014,"line_start":141,"line_end":141,"column_start":1,"column_end":4}},{"value":"/ pub struct Vec2<F> {","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6015,"byte_end":6039,"line_start":142,"line_end":142,"column_start":1,"column_end":25}},{"value":"/   pub x: F,","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6040,"byte_end":6055,"line_start":143,"line_end":143,"column_start":1,"column_end":16}},{"value":"/   pub y: F,","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6056,"byte_end":6071,"line_start":144,"line_end":144,"column_start":1,"column_end":16}},{"value":"/ }","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6072,"byte_end":6077,"line_start":145,"line_end":145,"column_start":1,"column_end":6}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6078,"byte_end":6081,"line_start":146,"line_end":146,"column_start":1,"column_end":4}},{"value":"/ impl<'a, M: Copy, F: Copy + ApproxEq<Margin=M>> ApproxEq for &'a Vec2<F> {","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6082,"byte_end":6160,"line_start":147,"line_end":147,"column_start":1,"column_end":79}},{"value":"/   type Margin = M;","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6161,"byte_end":6183,"line_start":148,"line_end":148,"column_start":1,"column_end":23}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6184,"byte_end":6187,"line_start":149,"line_end":149,"column_start":1,"column_end":4}},{"value":"/   fn approx_eq<T: Into<Self::Margin>>(self, other: Self, margin: T) -> bool {","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6188,"byte_end":6269,"line_start":150,"line_end":150,"column_start":1,"column_end":82}},{"value":"/     let margin = margin.into();","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6270,"byte_end":6305,"line_start":151,"line_end":151,"column_start":1,"column_end":36}},{"value":"/     self.x.approx_eq(other.x, margin)","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6306,"byte_end":6347,"line_start":152,"line_end":152,"column_start":1,"column_end":42}},{"value":"/       && self.y.approx_eq(other.y, margin)","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6348,"byte_end":6394,"line_start":153,"line_end":153,"column_start":1,"column_end":47}},{"value":"/   }","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6395,"byte_end":6402,"line_start":154,"line_end":154,"column_start":1,"column_end":8}},{"value":"/ }","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6403,"byte_end":6408,"line_start":155,"line_end":155,"column_start":1,"column_end":6}},{"value":"/ ```","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6409,"byte_end":6416,"line_start":156,"line_end":156,"column_start":1,"column_end":8}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6417,"byte_end":6420,"line_start":157,"line_end":157,"column_start":1,"column_end":4}},{"value":"/ ## Non floating-point types","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6421,"byte_end":6452,"line_start":158,"line_end":158,"column_start":1,"column_end":32}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6453,"byte_end":6456,"line_start":159,"line_end":159,"column_start":1,"column_end":4}},{"value":"/ `ApproxEq` can be implemented for non floating-point types as well, since `Margin` is","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6457,"byte_end":6546,"line_start":160,"line_end":160,"column_start":1,"column_end":90}},{"value":"/ an associated type.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6547,"byte_end":6570,"line_start":161,"line_end":161,"column_start":1,"column_end":24}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6571,"byte_end":6574,"line_start":162,"line_end":162,"column_start":1,"column_end":4}},{"value":"/ The `efloat` crate implements (or soon will implement) `ApproxEq` for a compound type","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6575,"byte_end":6664,"line_start":163,"line_end":163,"column_start":1,"column_end":90}},{"value":"/ that tracks floating point error bounds by checking if the error bounds overlap.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6665,"byte_end":6749,"line_start":164,"line_end":164,"column_start":1,"column_end":85}},{"value":"/ In that case `type Margin = ()`.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6750,"byte_end":6786,"line_start":165,"line_end":165,"column_start":1,"column_end":37}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6787,"byte_end":6790,"line_start":166,"line_end":166,"column_start":1,"column_end":4}},{"value":"/ ## Inspiration","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6791,"byte_end":6809,"line_start":167,"line_end":167,"column_start":1,"column_end":19}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6810,"byte_end":6813,"line_start":168,"line_end":168,"column_start":1,"column_end":4}},{"value":"/ This crate was inspired by this Random ASCII blog post:","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6814,"byte_end":6873,"line_start":169,"line_end":169,"column_start":1,"column_end":60}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6874,"byte_end":6877,"line_start":170,"line_end":170,"column_start":1,"column_end":4}},{"value":"/ [https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/)","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":6878,"byte_end":7068,"line_start":171,"line_end":171,"column_start":1,"column_end":191}}]},{"kind":"Function","id":{"krate":0,"index":7},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/lib.rs","byte_start":7158,"byte_end":7164,"line_start":179,"line_end":179,"column_start":8,"column_end":14},"name":"trials","qualname":"::trials","value":"pub fn trials()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":9},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":10832,"byte_end":10836,"line_start":26,"line_end":26,"column_start":11,"column_end":15},"name":"Ulps","qualname":"::ulps::Ulps","value":"Ulps","parent":null,"children":[{"krate":0,"index":10},{"krate":0,"index":11},{"krate":0,"index":12},{"krate":0,"index":13}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"cfg(not(feature = \"num_traits\"))","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":10788,"byte_end":10821,"line_start":25,"line_end":25,"column_start":1,"column_end":34}}]},{"kind":"Type","id":{"krate":0,"index":10},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":10848,"byte_end":10849,"line_start":27,"line_end":27,"column_start":10,"column_end":11},"name":"U","qualname":"::ulps::Ulps::U","value":"type U: Copy;","parent":{"krate":0,"index":9},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":11},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":11089,"byte_end":11093,"line_start":32,"line_end":32,"column_start":8,"column_end":12},"name":"ulps","qualname":"::ulps::Ulps::ulps","value":"pub fn ulps(&Self, &Self) -> <Self as Ulps>::U","parent":{"krate":0,"index":9},"children":[],"decl_id":null,"docs":" The number of representable values or ULPs (Units of Least Precision) that\n separate `self` and `other`.  The result `U` is an integral value, and will\n be zero if `self` and `other` are exactly equal.\n","sig":null,"attributes":[{"value":"/ The number of representable values or ULPs (Units of Least Precision) that","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":10862,"byte_end":10940,"line_start":29,"line_end":29,"column_start":5,"column_end":83}},{"value":"/ separate `self` and `other`.  The result `U` is an integral value, and will","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":10945,"byte_end":11024,"line_start":30,"line_end":30,"column_start":5,"column_end":84}},{"value":"/ be zero if `self` and `other` are exactly equal.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":11029,"byte_end":11081,"line_start":31,"line_end":31,"column_start":5,"column_end":57}}]},{"kind":"Method","id":{"krate":0,"index":12},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":11198,"byte_end":11202,"line_start":35,"line_end":35,"column_start":8,"column_end":12},"name":"next","qualname":"::ulps::Ulps::next","value":"pub fn next(&Self) -> Self","parent":{"krate":0,"index":9},"children":[],"decl_id":null,"docs":" The next representable number above this one\n","sig":null,"attributes":[{"value":"/ The next representable number above this one","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":11142,"byte_end":11190,"line_start":34,"line_end":34,"column_start":5,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":13},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":11284,"byte_end":11288,"line_start":38,"line_end":38,"column_start":8,"column_end":12},"name":"prev","qualname":"::ulps::Ulps::prev","value":"pub fn prev(&Self) -> Self","parent":{"krate":0,"index":9},"children":[],"decl_id":null,"docs":" The previous representable number below this one\n","sig":null,"attributes":[{"value":"/ The previous representable number below this one","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps.rs","byte_start":11224,"byte_end":11276,"line_start":37,"line_end":37,"column_start":5,"column_end":57}}]},{"kind":"Trait","id":{"krate":0,"index":27},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":16983,"byte_end":16995,"line_start":10,"line_end":10,"column_start":11,"column_end":23},"name":"ApproxEqUlps","qualname":"::ulps_eq::ApproxEqUlps","value":"ApproxEqUlps","parent":null,"children":[{"krate":0,"index":28},{"krate":0,"index":29},{"krate":0,"index":30}],"decl_id":null,"docs":" ApproxEqUlps is a trait for approximate equality comparisons.\n The associated type Flt is a floating point type which implements Ulps, and is\n required so that this trait can be implemented for compound types (e.g. vectors),\n not just for the floats themselves.\n","sig":null,"attributes":[{"value":"/ ApproxEqUlps is a trait for approximate equality comparisons.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":16698,"byte_end":16763,"line_start":6,"line_end":6,"column_start":1,"column_end":66}},{"value":"/ The associated type Flt is a floating point type which implements Ulps, and is","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":16764,"byte_end":16846,"line_start":7,"line_end":7,"column_start":1,"column_end":83}},{"value":"/ required so that this trait can be implemented for compound types (e.g. vectors),","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":16847,"byte_end":16932,"line_start":8,"line_end":8,"column_start":1,"column_end":86}},{"value":"/ not just for the floats themselves.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":16933,"byte_end":16972,"line_start":9,"line_end":9,"column_start":1,"column_end":40}}]},{"kind":"Type","id":{"krate":0,"index":28},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17007,"byte_end":17010,"line_start":11,"line_end":11,"column_start":10,"column_end":13},"name":"Flt","qualname":"::ulps_eq::ApproxEqUlps::Flt","value":"type Flt: Ulps;","parent":{"krate":0,"index":27},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":29},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17370,"byte_end":17384,"line_start":18,"line_end":18,"column_start":8,"column_end":22},"name":"approx_eq_ulps","qualname":"::ulps_eq::ApproxEqUlps::approx_eq_ulps","value":"pub fn approx_eq_ulps(&Self, &Self, <Self::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":27},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be approximately equal\n within ULPs (Units of Least Precision) floating point representations.\n Differing signs are always unequal with this method, and zeroes are only\n equal to zeroes. Use approx_eq() from the ApproxEq trait if that is more\n appropriate.\n","sig":null,"attributes":[{"value":"/ This method tests for `self` and `other` values to be approximately equal","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17023,"byte_end":17100,"line_start":13,"line_end":13,"column_start":5,"column_end":82}},{"value":"/ within ULPs (Units of Least Precision) floating point representations.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17105,"byte_end":17179,"line_start":14,"line_end":14,"column_start":5,"column_end":79}},{"value":"/ Differing signs are always unequal with this method, and zeroes are only","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17184,"byte_end":17260,"line_start":15,"line_end":15,"column_start":5,"column_end":81}},{"value":"/ equal to zeroes. Use approx_eq() from the ApproxEq trait if that is more","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17265,"byte_end":17341,"line_start":16,"line_end":16,"column_start":5,"column_end":81}},{"value":"/ appropriate.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17346,"byte_end":17362,"line_start":17,"line_end":17,"column_start":5,"column_end":21}}]},{"kind":"Method","id":{"krate":0,"index":30},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17815,"byte_end":17829,"line_start":26,"line_end":26,"column_start":8,"column_end":22},"name":"approx_ne_ulps","qualname":"::ulps_eq::ApproxEqUlps::approx_ne_ulps","value":"pub fn approx_ne_ulps(&Self, &Self, <Self::Flt as Ulps>::U) -> bool","parent":{"krate":0,"index":27},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be not approximately\n equal within ULPs (Units of Least Precision) floating point representations.\n Differing signs are always unequal with this method, and zeroes are only\n equal to zeroes. Use approx_eq() from the ApproxEq trait if that is more\n appropriate.\n","sig":null,"attributes":[{"value":"/ This method tests for `self` and `other` values to be not approximately","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17450,"byte_end":17525,"line_start":20,"line_end":20,"column_start":5,"column_end":80}},{"value":"/ equal within ULPs (Units of Least Precision) floating point representations.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17530,"byte_end":17610,"line_start":21,"line_end":21,"column_start":5,"column_end":85}},{"value":"/ Differing signs are always unequal with this method, and zeroes are only","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17615,"byte_end":17691,"line_start":22,"line_end":22,"column_start":5,"column_end":81}},{"value":"/ equal to zeroes. Use approx_eq() from the ApproxEq trait if that is more","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17696,"byte_end":17772,"line_start":23,"line_end":23,"column_start":5,"column_end":81}},{"value":"/ appropriate.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17777,"byte_end":17793,"line_start":24,"line_end":24,"column_start":5,"column_end":21}},{"value":"inline","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_eq.rs","byte_start":17798,"byte_end":17807,"line_start":25,"line_end":25,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":45},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21428,"byte_end":21441,"line_start":15,"line_end":15,"column_start":11,"column_end":24},"name":"ApproxOrdUlps","qualname":"::ulps_ord::ApproxOrdUlps","value":"ApproxOrdUlps: ApproxEqUlps","parent":null,"children":[{"krate":0,"index":46},{"krate":0,"index":47},{"krate":0,"index":48},{"krate":0,"index":49},{"krate":0,"index":50}],"decl_id":null,"docs":" ApproxOrdUlps is for sorting floating point values where approximate equality\n is considered equal.  This is only really useful for types which cannot\n implement Ord","sig":null,"attributes":[{"value":"/ ApproxOrdUlps is for sorting floating point values where approximate equality","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21032,"byte_end":21113,"line_start":8,"line_end":8,"column_start":1,"column_end":82}},{"value":"/ is considered equal.  This is only really useful for types which cannot","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21114,"byte_end":21189,"line_start":9,"line_end":9,"column_start":1,"column_end":76}},{"value":"/ implement Ord","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21190,"byte_end":21207,"line_start":10,"line_end":10,"column_start":1,"column_end":18}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21208,"byte_end":21211,"line_start":11,"line_end":11,"column_start":1,"column_end":4}},{"value":"/ This is deprecated. If you are using this type, please contact the author and","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21212,"byte_end":21293,"line_start":12,"line_end":12,"column_start":1,"column_end":82}},{"value":"/ explain how it is useful.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21294,"byte_end":21323,"line_start":13,"line_end":13,"column_start":1,"column_end":30}},{"value":"deprecated(since = \"0.5.0\", note =\n             \"types that can implement this can implement PartialOrd\")","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21324,"byte_end":21417,"line_start":14,"line_end":14,"column_start":1,"column_end":94}}]},{"kind":"Method","id":{"krate":0,"index":46},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21737,"byte_end":21752,"line_start":20,"line_end":20,"column_start":8,"column_end":23},"name":"approx_cmp_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_cmp_ulps","value":"pub fn approx_cmp_ulps(&Self, &Self, <<Self as ApproxEqUlps>::Flt as Ulps>::U)\n-> Ordering","parent":{"krate":0,"index":45},"children":[],"decl_id":null,"docs":" This method returns an ordering between `self` and `other` values\n if one exists, where Equal is returned if they are approximately\n equal within `ulps` floating point representations.  See module\n documentation for an understanding of `ulps`\n","sig":null,"attributes":[{"value":"/ This method returns an ordering between `self` and `other` values","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21462,"byte_end":21531,"line_start":16,"line_end":16,"column_start":5,"column_end":74}},{"value":"/ if one exists, where Equal is returned if they are approximately","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21536,"byte_end":21604,"line_start":17,"line_end":17,"column_start":5,"column_end":73}},{"value":"/ equal within `ulps` floating point representations.  See module","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21609,"byte_end":21676,"line_start":18,"line_end":18,"column_start":5,"column_end":72}},{"value":"/ documentation for an understanding of `ulps`","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21681,"byte_end":21729,"line_start":19,"line_end":19,"column_start":5,"column_end":53}}]},{"kind":"Method","id":{"krate":0,"index":47},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22074,"byte_end":22088,"line_start":27,"line_end":27,"column_start":8,"column_end":22},"name":"approx_lt_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_lt_ulps","value":"pub fn approx_lt_ulps(&Self, &Self, <<Self as ApproxEqUlps>::Flt as Ulps>::U)\n-> bool","parent":{"krate":0,"index":45},"children":[],"decl_id":null,"docs":" This method tests less than (for `self` < `other`), where values\n within `ulps` of each other are not less than.  See module\n documentation for an understanding of `ulps`.\n","sig":null,"attributes":[{"value":"/ This method tests less than (for `self` < `other`), where values","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21863,"byte_end":21931,"line_start":23,"line_end":23,"column_start":5,"column_end":73}},{"value":"/ within `ulps` of each other are not less than.  See module","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21936,"byte_end":21998,"line_start":24,"line_end":24,"column_start":5,"column_end":67}},{"value":"/ documentation for an understanding of `ulps`.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22003,"byte_end":22052,"line_start":25,"line_end":25,"column_start":5,"column_end":54}},{"value":"inline","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22057,"byte_end":22066,"line_start":26,"line_end":26,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":48},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22526,"byte_end":22540,"line_start":40,"line_end":40,"column_start":8,"column_end":22},"name":"approx_le_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_le_ulps","value":"pub fn approx_le_ulps(&Self, &Self, <<Self as ApproxEqUlps>::Flt as Ulps>::U)\n-> bool","parent":{"krate":0,"index":45},"children":[],"decl_id":null,"docs":" This method tests less than or equal to (for `self` <= `other`)\n where values within `ulps` are equal.  See module documentation\n for an understanding of `ulps`.\n","sig":null,"attributes":[{"value":"/ This method tests less than or equal to (for `self` <= `other`)","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22325,"byte_end":22392,"line_start":36,"line_end":36,"column_start":5,"column_end":72}},{"value":"/ where values within `ulps` are equal.  See module documentation","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22397,"byte_end":22464,"line_start":37,"line_end":37,"column_start":5,"column_end":72}},{"value":"/ for an understanding of `ulps`.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22469,"byte_end":22504,"line_start":38,"line_end":38,"column_start":5,"column_end":40}},{"value":"inline","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22509,"byte_end":22518,"line_start":39,"line_end":39,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":49},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22996,"byte_end":23010,"line_start":53,"line_end":53,"column_start":8,"column_end":22},"name":"approx_gt_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_gt_ulps","value":"pub fn approx_gt_ulps(&Self, &Self, <<Self as ApproxEqUlps>::Flt as Ulps>::U)\n-> bool","parent":{"krate":0,"index":45},"children":[],"decl_id":null,"docs":" This method tests greater than (for `self` > `other`)\n where values within `ulps` are not greater than.  See module\n documentation for an understanding of `ulps`\n","sig":null,"attributes":[{"value":"/ This method tests greater than (for `self` > `other`)","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22795,"byte_end":22852,"line_start":49,"line_end":49,"column_start":5,"column_end":62}},{"value":"/ where values within `ulps` are not greater than.  See module","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22857,"byte_end":22921,"line_start":50,"line_end":50,"column_start":5,"column_end":69}},{"value":"/ documentation for an understanding of `ulps`","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22926,"byte_end":22974,"line_start":51,"line_end":51,"column_start":5,"column_end":53}},{"value":"inline","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":22979,"byte_end":22988,"line_start":52,"line_end":52,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":50},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":23453,"byte_end":23467,"line_start":66,"line_end":66,"column_start":8,"column_end":22},"name":"approx_ge_ulps","qualname":"::ulps_ord::ApproxOrdUlps::approx_ge_ulps","value":"pub fn approx_ge_ulps(&Self, &Self, <<Self as ApproxEqUlps>::Flt as Ulps>::U)\n-> bool","parent":{"krate":0,"index":45},"children":[],"decl_id":null,"docs":" This method tests greater than or equal to (for `self` > `other`)\n where values within `ulps` are equal.  See module documentation\n for an understanding of `ulps`.\n","sig":null,"attributes":[{"value":"/ This method tests greater than or equal to (for `self` > `other`)","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":23250,"byte_end":23319,"line_start":62,"line_end":62,"column_start":5,"column_end":74}},{"value":"/ where values within `ulps` are equal.  See module documentation","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":23324,"byte_end":23391,"line_start":63,"line_end":63,"column_start":5,"column_end":72}},{"value":"/ for an understanding of `ulps`.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":23396,"byte_end":23431,"line_start":64,"line_end":64,"column_start":5,"column_end":40}},{"value":"inline","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":23436,"byte_end":23445,"line_start":65,"line_end":65,"column_start":5,"column_end":14}}]},{"kind":"Trait","id":{"krate":0,"index":61},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":31760,"byte_end":31768,"line_start":10,"line_end":10,"column_start":11,"column_end":19},"name":"ApproxEq","qualname":"::eq::ApproxEq","value":"ApproxEq: Sized","parent":null,"children":[{"krate":0,"index":62},{"krate":0,"index":63},{"krate":0,"index":65}],"decl_id":null,"docs":" ApproxEq is a trait for approximate equality comparisons.\n The associated type defines a margin within which two values are to be\n considered approximately equal.\n","sig":null,"attributes":[{"value":"/ ApproxEq is a trait for approximate equality comparisons.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":31577,"byte_end":31638,"line_start":7,"line_end":7,"column_start":1,"column_end":62}},{"value":"/ The associated type defines a margin within which two values are to be","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":31639,"byte_end":31713,"line_start":8,"line_end":8,"column_start":1,"column_end":75}},{"value":"/ considered approximately equal.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":31714,"byte_end":31749,"line_start":9,"line_end":9,"column_start":1,"column_end":36}}]},{"kind":"Type","id":{"krate":0,"index":62},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":31787,"byte_end":31793,"line_start":11,"line_end":11,"column_start":10,"column_end":16},"name":"Margin","qualname":"::eq::ApproxEq::Margin","value":"type Margin: Copy;","parent":{"krate":0,"index":61},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":63},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":31916,"byte_end":31925,"line_start":15,"line_end":15,"column_start":8,"column_end":17},"name":"approx_eq","qualname":"::eq::ApproxEq::approx_eq","value":"pub fn approx_eq<M: Into<Self::Margin>>(Self, Self, M) -> bool","parent":{"krate":0,"index":61},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be approximately equal\n within `margin`.\n","sig":null,"attributes":[{"value":"/ This method tests for `self` and `other` values to be approximately equal","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":31806,"byte_end":31883,"line_start":13,"line_end":13,"column_start":5,"column_end":82}},{"value":"/ within `margin`.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":31888,"byte_end":31908,"line_start":14,"line_end":14,"column_start":5,"column_end":25}}]},{"kind":"Method","id":{"krate":0,"index":65},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32107,"byte_end":32116,"line_start":19,"line_end":19,"column_start":8,"column_end":17},"name":"approx_ne","qualname":"::eq::ApproxEq::approx_ne","value":"pub fn approx_ne<M: Into<Self::Margin>>(Self, Self, M) -> bool","parent":{"krate":0,"index":61},"children":[],"decl_id":null,"docs":" This method tests for `self` and `other` values to be not approximately\n equal within `margin`.\n","sig":null,"attributes":[{"value":"/ This method tests for `self` and `other` values to be not approximately","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":31993,"byte_end":32068,"line_start":17,"line_end":17,"column_start":5,"column_end":80}},{"value":"/ equal within `margin`.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32073,"byte_end":32099,"line_start":18,"line_end":18,"column_start":5,"column_end":31}}]},{"kind":"Struct","id":{"krate":0,"index":95},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33311,"byte_end":33320,"line_start":43,"line_end":43,"column_start":12,"column_end":21},"name":"F32Margin","qualname":"::eq::F32Margin","value":"F32Margin { epsilon, ulps }","parent":null,"children":[{"krate":0,"index":96},{"krate":0,"index":97}],"decl_id":null,"docs":" This type defines a margin within two f32s might be considered equal\n and is intended as the associated type for the `ApproxEq` trait.","sig":null,"attributes":[{"value":"/ This type defines a margin within two f32s might be considered equal","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32228,"byte_end":32300,"line_start":24,"line_end":24,"column_start":1,"column_end":73}},{"value":"/ and is intended as the associated type for the `ApproxEq` trait.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32301,"byte_end":32369,"line_start":25,"line_end":25,"column_start":1,"column_end":69}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32370,"byte_end":32373,"line_start":26,"line_end":26,"column_start":1,"column_end":4}},{"value":"/ Two methods are used to determine approximate equality.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32374,"byte_end":32433,"line_start":27,"line_end":27,"column_start":1,"column_end":60}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32434,"byte_end":32437,"line_start":28,"line_end":28,"column_start":1,"column_end":4}},{"value":"/ First an epsilon method is used, considering them approximately equal if they","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32438,"byte_end":32519,"line_start":29,"line_end":29,"column_start":1,"column_end":82}},{"value":"/ differ by <= `epsilon`.  This will only succeed for very small numbers.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32520,"byte_end":32595,"line_start":30,"line_end":30,"column_start":1,"column_end":76}},{"value":"/ Note that it may succeed even if the parameters are of differing signs straddling","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32596,"byte_end":32681,"line_start":31,"line_end":31,"column_start":1,"column_end":86}},{"value":"/ zero.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32682,"byte_end":32691,"line_start":32,"line_end":32,"column_start":1,"column_end":10}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32692,"byte_end":32695,"line_start":33,"line_end":33,"column_start":1,"column_end":4}},{"value":"/ The second method considers how many ULPs (units of least precision, units in","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32696,"byte_end":32777,"line_start":34,"line_end":34,"column_start":1,"column_end":82}},{"value":"/ the last place, which is the integer number of floating point representations","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32778,"byte_end":32859,"line_start":35,"line_end":35,"column_start":1,"column_end":82}},{"value":"/ that the parameters are separated by) different the parameters are and considers","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32860,"byte_end":32944,"line_start":36,"line_end":36,"column_start":1,"column_end":85}},{"value":"/ them approximately equal if this is <= `ulps`. For large floating point numbers,","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":32945,"byte_end":33029,"line_start":37,"line_end":37,"column_start":1,"column_end":85}},{"value":"/ an ULP can be a rather large gap, but this kind of comparison is necessary","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33030,"byte_end":33108,"line_start":38,"line_end":38,"column_start":1,"column_end":79}},{"value":"/ because floating point operations must round to the nearest representable value","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33109,"byte_end":33192,"line_start":39,"line_end":39,"column_start":1,"column_end":84}},{"value":"/ and so larger floating point values accumulate larger errors.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33193,"byte_end":33258,"line_start":40,"line_end":40,"column_start":1,"column_end":66}},{"value":"repr(C)","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33259,"byte_end":33269,"line_start":41,"line_end":41,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":96},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33331,"byte_end":33338,"line_start":44,"line_end":44,"column_start":9,"column_end":16},"name":"epsilon","qualname":"::eq::F32Margin::epsilon","value":"f32","parent":{"krate":0,"index":95},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":97},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33353,"byte_end":33357,"line_start":45,"line_end":45,"column_start":9,"column_end":13},"name":"ulps","qualname":"::eq::F32Margin::ulps","value":"i32","parent":{"krate":0,"index":95},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":70},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33575,"byte_end":33579,"line_start":58,"line_end":58,"column_start":12,"column_end":16},"name":"zero","qualname":"<F32Margin>::zero","value":"pub fn zero() -> F32Margin","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33554,"byte_end":33563,"line_start":57,"line_end":57,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":71},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33690,"byte_end":33697,"line_start":64,"line_end":64,"column_start":12,"column_end":19},"name":"epsilon","qualname":"<F32Margin>::epsilon","value":"pub fn epsilon(Self, f32) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":72},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33824,"byte_end":33828,"line_start":70,"line_end":70,"column_start":12,"column_end":16},"name":"ulps","qualname":"<F32Margin>::ulps","value":"pub fn ulps(Self, i32) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":103},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37238,"byte_end":37247,"line_start":171,"line_end":171,"column_start":12,"column_end":21},"name":"F64Margin","qualname":"::eq::F64Margin","value":"F64Margin { epsilon, ulps }","parent":null,"children":[{"krate":0,"index":104},{"krate":0,"index":105}],"decl_id":null,"docs":" This type defines a margin within two f32s might be considered equal\n and is intended as the associated type for the `ApproxEq` trait.","sig":null,"attributes":[{"value":"/ This type defines a margin within two f32s might be considered equal","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36169,"byte_end":36241,"line_start":153,"line_end":153,"column_start":1,"column_end":73}},{"value":"/ and is intended as the associated type for the `ApproxEq` trait.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36242,"byte_end":36310,"line_start":154,"line_end":154,"column_start":1,"column_end":69}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36311,"byte_end":36314,"line_start":155,"line_end":155,"column_start":1,"column_end":4}},{"value":"/ Two methods are used to determine approximate equality.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36315,"byte_end":36374,"line_start":156,"line_end":156,"column_start":1,"column_end":60}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36375,"byte_end":36378,"line_start":157,"line_end":157,"column_start":1,"column_end":4}},{"value":"/ First an epsilon method is used, considering them approximately equal if they","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36379,"byte_end":36460,"line_start":158,"line_end":158,"column_start":1,"column_end":82}},{"value":"/ differ by <= `epsilon`.  This will only succeed for very small numbers.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36461,"byte_end":36536,"line_start":159,"line_end":159,"column_start":1,"column_end":76}},{"value":"/ Note that it may succeed even if the parameters are of differing signs straddling","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36537,"byte_end":36622,"line_start":160,"line_end":160,"column_start":1,"column_end":86}},{"value":"/ zero.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36623,"byte_end":36632,"line_start":161,"line_end":161,"column_start":1,"column_end":10}},{"value":"/","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36633,"byte_end":36636,"line_start":162,"line_end":162,"column_start":1,"column_end":4}},{"value":"/ The second method considers how many ULPs (units of least precision, units in","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36637,"byte_end":36718,"line_start":163,"line_end":163,"column_start":1,"column_end":82}},{"value":"/ the last place, which is the integer number of floating point representations","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36719,"byte_end":36800,"line_start":164,"line_end":164,"column_start":1,"column_end":82}},{"value":"/ that the parameters are separated by) different the parameters are and considers","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36801,"byte_end":36885,"line_start":165,"line_end":165,"column_start":1,"column_end":85}},{"value":"/ them approximately equal if this <= `ulps`. For large floating point numbers,","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36886,"byte_end":36967,"line_start":166,"line_end":166,"column_start":1,"column_end":82}},{"value":"/ an ULP can be a rather large gap, but this kind of comparison is necessary","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":36968,"byte_end":37046,"line_start":167,"line_end":167,"column_start":1,"column_end":79}},{"value":"/ because floating point operations must round to the nearest representable value","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37047,"byte_end":37130,"line_start":168,"line_end":168,"column_start":1,"column_end":84}},{"value":"/ and so larger floating point values accumulate larger errors.","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37131,"byte_end":37196,"line_start":169,"line_end":169,"column_start":1,"column_end":66}}]},{"kind":"Field","id":{"krate":0,"index":104},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37258,"byte_end":37265,"line_start":172,"line_end":172,"column_start":9,"column_end":16},"name":"epsilon","qualname":"::eq::F64Margin::epsilon","value":"f64","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":105},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37280,"byte_end":37284,"line_start":173,"line_end":173,"column_start":9,"column_end":13},"name":"ulps","qualname":"::eq::F64Margin::ulps","value":"i64","parent":{"krate":0,"index":103},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":82},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37502,"byte_end":37506,"line_start":186,"line_end":186,"column_start":12,"column_end":16},"name":"zero","qualname":"<F64Margin>::zero","value":"pub fn zero() -> F64Margin","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"inline","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37481,"byte_end":37490,"line_start":185,"line_end":185,"column_start":5,"column_end":14}}]},{"kind":"Method","id":{"krate":0,"index":83},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37617,"byte_end":37624,"line_start":192,"line_end":192,"column_start":12,"column_end":19},"name":"epsilon","qualname":"<F64Margin>::epsilon","value":"pub fn epsilon(Self, f64) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":84},"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37751,"byte_end":37755,"line_start":198,"line_end":198,"column_start":12,"column_end":16},"name":"ulps","qualname":"<F64Margin>::ulps","value":"pub fn ulps(Self, i64) -> Self","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]}],"impls":[{"id":6,"kind":"Direct","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33382,"byte_end":33391,"line_start":47,"line_end":47,"column_start":18,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":68}],"docs":"","sig":null,"attributes":[]},{"id":7,"kind":"Inherent","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33538,"byte_end":33547,"line_start":56,"line_end":56,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":70},{"krate":0,"index":71},{"krate":0,"index":72}],"docs":"","sig":null,"attributes":[]},{"id":8,"kind":"Direct","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33963,"byte_end":33972,"line_start":77,"line_end":77,"column_start":27,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":74}],"docs":"","sig":null,"attributes":[]},{"id":10,"kind":"Direct","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37309,"byte_end":37318,"line_start":175,"line_end":175,"column_start":18,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":80}],"docs":"","sig":null,"attributes":[]},{"id":11,"kind":"Inherent","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37465,"byte_end":37474,"line_start":184,"line_end":184,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":82},{"krate":0,"index":83},{"krate":0,"index":84}],"docs":"","sig":null,"attributes":[]},{"id":12,"kind":"Direct","span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37890,"byte_end":37899,"line_start":205,"line_end":205,"column_start":27,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":86}],"docs":"","sig":null,"attributes":[]}],"refs":[],"macro_refs":[],"relations":[{"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/ulps_ord.rs","byte_start":21443,"byte_end":21455,"line_start":15,"line_end":15,"column_start":26,"column_end":38},"kind":"SuperTrait","from":{"krate":0,"index":27},"to":{"krate":0,"index":45}},{"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":31770,"byte_end":31775,"line_start":10,"line_end":10,"column_start":21,"column_end":26},"kind":"SuperTrait","from":{"krate":2,"index":2076},"to":{"krate":0,"index":61}},{"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33382,"byte_end":33391,"line_start":47,"line_end":47,"column_start":18,"column_end":27},"kind":{"Impl":{"id":6}},"from":{"krate":0,"index":95},"to":{"krate":2,"index":2059}},{"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33538,"byte_end":33547,"line_start":56,"line_end":56,"column_start":6,"column_end":15},"kind":{"Impl":{"id":7}},"from":{"krate":0,"index":95},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":33963,"byte_end":33972,"line_start":77,"line_end":77,"column_start":27,"column_end":36},"kind":{"Impl":{"id":8}},"from":{"krate":0,"index":95},"to":{"krate":2,"index":1989}},{"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37309,"byte_end":37318,"line_start":175,"line_end":175,"column_start":18,"column_end":27},"kind":{"Impl":{"id":10}},"from":{"krate":0,"index":103},"to":{"krate":2,"index":2059}},{"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37465,"byte_end":37474,"line_start":184,"line_end":184,"column_start":6,"column_end":15},"kind":{"Impl":{"id":11}},"from":{"krate":0,"index":103},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/home/sna/.cargo/registry/src/github.com-1ecc6299db9ec823/float-cmp-0.5.3/src/eq.rs","byte_start":37890,"byte_end":37899,"line_start":205,"line_end":205,"column_start":27,"column_end":36},"kind":{"Impl":{"id":12}},"from":{"krate":0,"index":103},"to":{"krate":2,"index":1989}}]}